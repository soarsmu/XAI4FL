# -*- coding: utf-8 -*-
"""LIME-testing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1R0bHK6EF6z05j6gscP7fAXqHMapSssbP
"""

# Remember to pip install lime

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from lime.lime_tabular import LimeTabularExplainer
from matplotlib import pyplot as plt
import pandas as pd
import json
import re
import ast
import sys
import numpy as np

def process_matrix(file_obj, file_name):
    file_string = str(file_obj[file_name])

    result = file_string.split("\\n")
    result[0] = result[0].replace("b'", "")

    for i in range(len(result)):
        result[i] = result[i].split(" ")
        result[i] = [int(x) if x.isdigit() else x for x in result[i]]
        lastel = result[i][-1]
        if lastel == "+":
            result[i][-1] = 1
        elif lastel == "-":
            result[i][-1] = 0
    
    return result

def make_line_in_txt_lime(exp_instance):
    exp_in_list = exp_instance.as_list()
    new_list = []

    for i in exp_in_list:
        if ("<=" in i[0]):
            string_split = " <= "
        elif (">=" in i[0]):
            string_split = " >= "
        elif ("<" in i[0]):
            string_split = " < "
        elif (">" in i[0]):
            string_split = " > "
        feature = i[0].split(string_split)
        index = int(feature[0])
        feature[0] = list(df.columns.values)[index]
        new_list.append(";".join([feature[0], str(i[1])]))
    
    return new_list

def write_output_file(filename, obj, is_reverse=False):
    with open(filename, 'w') as file:
        sorted_dict = sorted(obj.items(), key=lambda x: x[1], reverse=is_reverse)
        for i in sorted_dict:
            file.write(";".join([i[0], str(i[1])]) + "\n")

#Input and process files into dataframe
#Input: File paths, both spectra and matrix. System finds the files
#Output: Dataframe (Spectra List + PASS/FAIL labels as column and Test instances as rows with its execution matrix)

f = open(sys.argv[1], "r")
spectra_list = [line.rstrip('\n') for line in f]
spectra_list.append("Pass/Fail")
f.close()

#Case if there are duplicate in list
seen = {}
for i, x in enumerate(spectra_list):
    if x not in seen:
        seen[x] = 1
    else:
        seen[x] += 1
        num = seen[x]
        temp = x.split('#')
        temp_name = temp[0] + str(num)+ '#' + temp[1]
        spectra_list[i] = temp_name 

df = pd.read_csv(sys.argv[2], sep=' ', names=spectra_list, header=None)
df = df.replace(["-","+"], [0,1])

#Split dataframe into variables and classes as well as handle any insufficient data 
#(Handles insufficient number labelled instance by appending a copy of that instance; Handles insufficient total number of instance by reappending the dataframe)
#Input: Dataframe created from spectra and matrix files
#Output: Dataset for model training and model testing (e.g., x_train -> instance feature values for training, y_test -> instance label for training)

x = df[spectra_list[:len(spectra_list)-1]]
y = df["Pass/Fail"]

fails = []
passes = []
i = 0
for result in y:
    if result == 0:
        fails.append(i)
    else:
        passes.append(i)
    i += 1

if len(fails) == 1:
    df = df.append(df.iloc[fails[0]])
    x = df[spectra_list[:len(spectra_list)-1]]
    y = df["Pass/Fail"]

if (df.shape[0] < 6):
    df = df.append(df)
    x = df[spectra_list[:len(spectra_list)-1]]
    y = df["Pass/Fail"]

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, stratify=y, random_state=1)

#Declare and train the model (Current model is Random Forest)
#Input: Training dataset (x_train, y_train)
#Output: Trained model

model = RandomForestClassifier(n_estimators=100, bootstrap=True, max_features='sqrt', random_state=1)

model.fit(x_train, y_train)

#Declares LIME explainer object and explains variable's contribution using LIME Tabular explainer
#Input: Trained model and array of "FAIL"-labelled instances
#Output: Dictionary of each line of code (feature)'s LIME values

lime_to_txt = {}

explainer = LimeTabularExplainer(training_data= np.array(x_train), mode="classification", feature_selection="auto")

for i in fails:
    exp_instance = explainer.explain_instance(x.iloc[i], predict_fn=model.predict_proba)
    lime_to_txt[x.iloc[i].name] = []
    lime_to_txt[x.iloc[i].name] += make_line_in_txt_lime(exp_instance)
    #Only gathers top 10 most contributing feature based on LIME local explanation

#Process individual LIME values as well as mean, max, and min LIME values for each test case
#Input: Dictionary of each line of code (feature)'s LIME values
#Output: Dictionaries of each line of code's mean, max, and min LIME values

lime_lines_output_val = {}

for i in lime_to_txt:
    for index, value in enumerate(lime_to_txt[i]):
        feature_and_value = value.split(";")
        feature = feature_and_value[0]
        lime_val =  float(feature_and_value[1])
        if feature not in lime_lines_output_val:
            lime_lines_output_val[feature] = []
        lime_lines_output_val[feature].append(lime_val)

lime_means = {}
lime_max = {}
lime_min = {}

for i in lime_lines_output_val:
    if i not in lime_means:
        lime_means[i] = []
    if i not in lime_min:
        lime_min[i] = lime_lines_output_val[i][0]
    if i not in lime_max:
        lime_max[i] = lime_lines_output_val[i][0]
    for j in lime_lines_output_val[i]:
        lime_means[i].append(j)
        if abs(lime_max[i]) < abs(j):
            lime_max[i] = j
        if abs(lime_min[i]) > abs(j):
            lime_min[i] = j

for i in lime_means:
    lime_means[i] = sum(lime_means[i]) / len(lime_means[i])

#Write output file
#Input: Dictionaries of each line of code's mean, max, and min LIME values
#Output: .txt Files containing each line of code's LIME values, mean, max, and min LIME values

with open(sys.argv[3] + "_lime_results.txt", "w") as file:
    for i in lime_to_txt:
        file.write(str(i) + "\n")
        for j in range(len(lime_to_txt[i])):
            file.write(lime_to_txt[i][j] + "\n")

write_output_file(sys.argv[3] + '_lime_mean.txt', lime_means)
write_output_file(sys.argv[3] + '_lime_min.txt', lime_min)
write_output_file(sys.argv[3] + '_lime_max.txt', lime_max)
